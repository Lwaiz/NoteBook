## 多态

#### 多态必须满足两个条件：

1 必须通过基类的指针或者引用调用虚函数
2 被调用的函数是虚函数，且必须完成对基类虚函数的重写

- 虚函数：使用virtual关键字修饰，只能是类中的非静态成员函数

- 虚函数重写（覆盖）：函数返回值类型  函数名 参数列表 完全一致

#### 多态分为两类

- 静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名

- 动态多态: 派生类和虚函数实现运行时多态

静态多态和动态多态区别：

- 静态多态的函数地址早绑定  -  编译阶段确定函数地址

- 动态多态的函数地址晚绑定  -  运行阶段确定函数地址

#### 新增关键字

- final：用final修饰的虚函数无法重写。用final修饰的类无法被继承。

```C++
class A final //A类无法被继承
{
public:
  virtual void fun() final //fun函数无法被重写
  {}
};
```

- 被override修饰的虚函数，编译器会检查这个虚函数是否重写。如果没有重写，编译器会报错。

```C++
class A  
{
public:
  virtual void fun() 
  {}
};

class B : public A 
{
  public:
  //这里我想重写fun，但写成了fun1，因为有override,编译器会报错。
    virtual void fun1() override
    {
     cout << endl;
    }
};

```

#### 重载 重写 重定义

1.重载：重载函数处在同一作用域。
函数名相同，函数列表必须不同。
2.覆盖：必须是虚函数，且处在父类和子类中。
返回值，参数列表，函数名必须完全相同（协变除外）。
3.重定义：子类和父类的成员变量相同或者函数名相同，
子类隐藏父类的对应成员。
子类和父类的同名函数不是重定义就是重写。



## 纯虚函数和抽象类

在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容

因此可以将虚函数改为**纯虚函数**

纯虚函数语法：`virtual 返回值类型 函数名 （参数列表）= 0 ;`

```C++
virtual void func() = 0;  //不用实现 只写接口就可以
```

当类中有了纯虚函数，这个类也称为==抽象类==（也叫接口类）

**抽象类特点**：

- 无法实例化对象

- 子类必须重写抽象类中的纯虚函数，否则也属于抽象类

当一个类中有虚函数 那么类中会存放一个虚函数表指针   在计算类大小的时候要加上这个指针的大小

## 虚析构和纯虚析构

多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码

解决方式：将父类中的析构函数改为**虚析构**或者**纯虚析构**

如果子类没有堆区数据   可以不写为虚析构或者纯虚析构

虚析构和纯虚析构共性：

- 可以解决父类指针释放子类对象

- 都需要有具体的函数实现

虚析构和纯虚析构区别：

- 如果是纯虚析构，该类属于抽象类，无法实例化对象

虚析构语法：

`virtual ~类名(){}`

纯虚析构语法：

 `virtual ~类名() = 0;`

`类名::~类名(){}`

```C++
class Animal {
public:
  
	virtual ~Animal() = 0;
};

Animal::~Animal()
```

