### 1.概述

C++中用构造函数和析构函数来初始化和清理对象，这两个函数将会被编译器自动调用。对象的初始化和清理是非常重要的，如果我们不提供构造函数与析构函数，编译器会自动提供两个函数的空实现。

- 构造函数：主要作用于创建函数时对对象成员的属性赋值。

- 析构函数：主要作用于在对象销毁前，执行一些清理工作（如释放new开辟在堆区的空间）。

```C++
class Person
{
public:
  
	Person()
	{
		cout << "调用构造函数" << endl;
	}
  
	~Person()//对象销毁前，自动调用
	{
		cout << "析构函数的调用" << endl;
	}
};
```

###  2.构造函数

构造函数语法：类名(){}
1.构造函数，没有返回值也不写void
2.函数名称与类名相同
3.构造函数可以有参数，因此可以发生重载
4.程序在调用对象时候会自动调用构造，无须手动调用，而且只会调用一次

#### 2.1 构造函数分类

```C++
//1.默认无参构造函数
    Person()
    {
        cout << "无参构造函数" << endl;
    }
    //2.有参构造函数
    Person(int a)
    {
        age = a;
        cout << "有参构造函数" << endl;
    }
    //3.拷贝构造函数
    Person(const Person& p)   //加const限定不能修改p
    {
        age = p.age;   //将p的参数赋值给当前类
        cout << "拷贝构造函数" << endl;
    }

```

#### 2.2构造函数调用

```C++
//括号法
Person p1; // 默认无参构造函数调用  不要加括号，会被编译器认为是一个函数声明
Person p2(10); //有参构造函数调用
Person p3(p2); //拷贝构造函数

//显示法
Person p1;
Person p2 = Person(10);  //有参构造调用   
Person p3 = Person(p2);  //拷贝构造函数调用  
// Person(10); // 匿名对象  当前行运行结束 系统会立即回收匿名对象
//不要利用拷贝构造函数初始化一个匿名对象  //Person (p3);

//隐式转换法
Person p4 = 10;  //有参构造  相当于Person p4 = Person(10);
Person p5 = p4;  //拷贝构造  相当于Person p5 = Person(p4);

```



#### 拷贝构造函数的调用时机



### 2.3 初始化列表

语法：构造函数( ): 属性1(值1)，属性2(值2)，属性3(值3)···{ }

```C++
class Person{
  public:
  //初始化列表方式初始化
  Person(int a, int b, int c):m_A(a),m_B(b),m_C(c){}
  private:
  int m_A;
  int m_B;
  int m_C;
};

  Person p(1,2,3);
```



### 3.析构函数

析构函数语法： ~类名(){}
1.析构函数，没有返回值也不写void
2.函数名称与类名相同,在名称前加上符号 ~
3.析构函数不可以有参数，因此不可以发生重载
4.程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次




如果在堆区创建成员属性  析构程序如下所示

```C++
Cat(string name)
    {
        cout << "Cat构造函数调用" << endl;
        m_Name = new string(name);
    }

~Cat()
    {
        cout << "Cat析构函数调用" << endl;
        if (this->m_Name != NULL)
        {
            delete m_Name;
            m_Name = NULL;
        }
    }
```





